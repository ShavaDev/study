"""
Работа с файлами

Самый простой способ открыть файл — функция open(). Однако в современном Python стандартом является использование оператора with.

Почему with (Context Manager) — это мастхэв?
Обычный вызов f = open() требует обязательного f.close(). Если между открытием и закрытием произойдет ошибка,
файл останется «зависшим» в оперативной памяти, что может привести к утечкам ресурсов.
Менеджер контекста гарантирует закрытие файла автоматически, даже если код упал.

Режимы работы (Modes)При открытии файла важно указать, что именно мы собираемся делать.
Режим   Описание
'r'     Read (Чтение). По умолчанию. Ошибка, если файла нет.
'w'     Write (Запись). Создает новый или полностью перезаписывает старый.
'wb'    Write Binary. Открываем файл на запись в бинарном режиме доступа
'a'     Append (Дозапись). Добавляет данные в конец файла.
'x'     Exclusive creation. Ошибка, если файл уже существует (защита от перезаписи).
'b'     Binary (Бинарный). Для картинок, видео или байтов.
'rb'    Read Binary. Читаем как сырые байты (нули и единицы) Зачем это нужно?
В текстовом режиме Python может запутаться с кодировками или спецсимволами переноса строки,
когда мы пытаемся «прыгать» по файлу. Для точного перемещения по байтам нужен именно бинарный режим.
'+'     Updating. Позволяет и читать, и писать одновременно (например, 'r+').

Методы, параметры файлов
1) file.read() считывает данные с файла, можно передать сколько символов нужно считать, однако
питон это запомнит и в следующий раз будет считывать с того места где закончил
2) file.seek(смещение, откуда) принимает число, то есть с какого символа продолжить/начать читать
У параметра откуда (второе число) есть три стандартных значения:
0 — Считать от начала файла (по умолчанию).
1 — Считать от текущей позиции курсора.
2 — Считать от конца файла.
f.seek(-100, 2)

    # Что произошло:
    # 2 означает "встань в самый конец файла"
    # -100 означает "отшагни назад на 100 байт"

3) file.readline() не принимает параметров, читает одну строчку целиком, также запоминает где остановился
Здесь концом строки считается символ переноса ‘\n’, либо конец файла.
Причем, этот спецсимвол переноса будет также присутствовать в строке.
4) file.readlines() не принимает параметров, создает список из строк, которые являются строками из файла
Здесь в консоли строчки будут разделены пустой строкой. Это как раз из-за того,
что один перенос идет из прочитанной строки, а второй добавляется самой функцией print().
Поэтому, если их записать вот так:
    print( file.readline(), end="" )
    print( file.readline(), end="" )
то вывод будет построчным с одним переносом.
5) file.write() принимает строку или текст, что мы хотим записать в файл
6) writelines(list) записывает список строк
7) f.tell() говорит где сейчас находится курсор (байт от начала), допустим мы прочитали 4 символа, а файловая позиция
равна 9 (еще 1 это невидимый символ FEFF), это потому что в кодировке utf-8 каждая буква кириллицы представляется
двумя байтами, а файловая позиция указывает не номер символа, а номер байта, поэтому файловая позиция 9


Буферизация (Buffering)
Когда ты вызываешь f.write("Hello"), данные не записываются на жесткий диск мгновенно. Запись на диск — операция дорогая (медленная). Поэтому Python (и операционная система) используют буфер — временную область в памяти.

Данные копятся в буфере.

Когда буфер заполняется или файл закрывается, происходит flush (сброс) данных на диск.

Ты можешь вызвать f.flush() принудительно, если тебе критично записать данные прямо сейчас, не закрывая файл.


Проблема кодировок (Encoding) и Ошибки
При работе с файлами из разных систем (Windows, Linux) ты столкнешься с битыми символами.
Параметр errors в open() позволяет решить, что делать с "плохими" байтами:

errors='strict': (по умолчанию) выкинет UnicodeDecodeError.

errors='ignore': просто пропустит мусор.

errors='replace': вставит знак вопроса вместо непонятного символа.


Временные файлы (Module tempfile)
Senior-разработчики не создают «мусорные» файлы test1.txt вручную.
Если тебе нужно сохранить данные временно (например, для обработки видео), используй библиотеку tempfile.
Она сама создаст файл с уникальным именем и удалит его сразу после закрытия программы.

"""

from pathlib import Path
import pickle # библиотека для записи данных в бинарном режиме

BASE_DIR = Path(__file__).resolve().parent
FILES_DIR = BASE_DIR / "files"
FILES_DIR.mkdir(parents=True, exist_ok=True)
FILE_TXT = FILES_DIR / "study.txt"
FILE_BINARY = FILES_DIR / "out.bin"


# file = open(FILE_TXT, encoding="utf-8", mode="w")
# file.write("Hello World")
# print(True)
# file.close()

try:
    with open(FILE_BINARY, mode="rb") as f: # поменял с wb на rb
        books =[
            ("Евгений Онегин", "Пушник А.С.", 200),
            ("Муму", "Тургенев И.С.", 250),
            ("Мастер и Маргарита", "Булгаков М.А.", 500),
            ("Мертвые души", "Гоголь Н.В.", 190)
        ]
        # pickle.dump(books, f)
        bs = pickle.load(f)
        print(bs)
except Exception as e:
    print(e)
finally:
    print(f.closed)


def binary_mod():
    """
    Бинарный режим (двоичный режим) — это метод работы с файлами в программировании,
    при котором данные считываются или записываются как последовательность байтов (0 и 1),
    без интерпретации их как текста. В отличие от текстового режима,
    здесь не происходит автоматического преобразования символов переноса строки или кодировок,
    что необходимо для работы с изображениями, видео и исполняемыми файлами
    :return:
    """
    pass