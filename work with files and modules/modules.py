"""
ИМПОРТ СТАНДАРТНЫХ МОДУЛЕЙ.

В действительности, модуль – это обычный текстовый файл программы на языке Python.
В этом легко убедиться, если в PyCharm нажать и удерживать клавишу Ctrl и щелкнуть по имени модуля, например, math.
Откроется файл и мы можем ознакомиться с его содержимым.

А что собственно делает конструкция import? Как он импортирует этот текст программы в нашу программу?
С помощью функции locals() выведу все локальные переменные нашей программы
В консоли у нас появился словарь и последними записями в нем идут имена math и time,
которые ссылаются на соответствующие импортированные модули
ак вот, все эти имена: math, pprint, time – это переменные в нашей программе и каждая ссылается
на свое пространство имен, со своими глобальными переменными. Например, чтобы посмотреть,
что содержит модуль math, можно получить все ее переменные с помощью функции dir
Мы видим полный список глобальных атрибутов этого модуля, включая имена функций и переменных.
То есть, чтобы обратиться к определенной функции в своей программе, нам нужно написать имя импортируемого модуля
и через точку указать имя функции или переменной

Все эти модули, что я использовал, поставляются вместе с языком Python и составляют его стандартную библиотеку.
Что еще входит в нее? Полный список модулей и подробное их описание приведено на странице официальной документации:
https://docs.python.org/3/library/

Но, если мы переопределим переменную, которая ссылается на модуль, к примеру math, на math = "математика", то уже
наш модуль math не будет ссылаться на стандартную библиотеку math попытки обратиться к функции или переменной приведут к ошибкам
для этого можно использовать конструкцию as name, к примеру import math as mt, теперь mt ссылается на стандартную библиотеку

Когда импортируется модуль через import, то автоматически подключается все его пространство имен к нашей программе.
Однако, часто из всего этого многообразия используется всего несколько функций или переменных.
И, если мы не хотим подключать модуль целиком, а сделать выборочный импорт некоторых его атрибутов,
то для этого следует использовать другую конструкцию:
from math import ceil, pi
теперь, при выводе:
pprint.pprint(locals())
мы не видим имя модуля math, но в пространстве имен нашей программы появляются имена ceil и pi.
То есть, для их использования мы теперь должны обращаться к ним напрямую
Но при таком импорте мы можем столкнуться с ситуацией, когда импортируемая функция (или переменная) переопределяется
в нашей программе. Например, если прописать свою собственную функцию ceil,
то именно она и будет вызвана, потому что сначала происходит импорт, а затем, объявление функции.
Если объявление функции сделать до импорта, то, наоборот, будет использована библиотечная функция, а наша затрется.
То есть, берется то, что определяется последним. Для решении проблемы опять можно использовать конструкцию as name


Функция locals() в Python возвращает словарь, который содержит все переменные,
определенные в текущей локальной области видимости

Функция dir() это встроенная функция, возвращающая список допустимых атрибутов,
методов и свойств переданного объекта в алфавитном порядке
Особенности: Если у объекта есть метод __dir__, функция вызовет его.
Если нет, она пытается получить атрибуты из __dict__

Функция help() это встроенный инструмент для получения интерактивной документации
по модулям, классам, функциям, методам и ключевым словам непосредственно в консоли.
Она выводит строку документации (docstring) объекта, помогая изучать код, не выходя из интерпретатора.


КАК ПРОИСХОДИТ ИМПОРТИРОВАНИЕ

import — это не просто объявление, это исполняемая инструкция (ключевое слово).
Когда Python доходит до строки с импортом, он запускает довольно сложный механизм.
Вот что происходит «под капотом» (упрощенно):
Поиск (Search): Python ищет файл с именем time. Он заглядывает в список путей sys.path
(там текущая папка, стандартные библиотеки и установленные пакеты).
Компиляция (Compile): Если найден исходный код (.py), Python компилирует его в байт-код (.pyc).
Исполнение (Execute): Это самый важный момент. Python выполняет код модуля сверху вниз.
Все функции, классы и переменные, определенные в файле time.py, создаются в отдельном объекте модуля.
Связывание (Binding): В вашем текущем скрипте создается переменная (в вашем случае time),
которая указывает на этот объект модуля в памяти.

конструкция import time -> time = __import__("time")

Где хранится сам код модуля?
Когда вы делаете import time первый раз, Python загружает его и кладет в sys.modules.
Когда вы делаете import time во втором файле или ниже по коду, Python не загружает его заново,
а просто дает вам ссылку на уже существующий объект из sys.modules. Это экономит память и время.


Интересный факт: Поскольку import — это обычная инструкция, её можно вложить внутрь функции.
Тогда модуль будет импортирован только в момент вызова функции и станет локальной переменной этой функции, а не глобальной.


В каждом модуле есть специальная переменная __name__, которая принимает имя модуля, если они запускается при импорте:
print(__name__)
и значение "__main__", если он запускается как самостоятельная программа (показываем).
И это свойство часто используют для контроля исполнения модуля. Если в нем нужно прописать программу,
выполняемую только при непосредственном запуске модуля, то ее следует поместить в следующее условие:
if __name__ == "__main__":
    print("Самостоятельный запуск")
else:
    print("Запуск при импорте")


модуль импортируется только один раз. Например, если прописать два импорта подряд:
import mymodule
import mymodule
то увидим только одно сообщение. Это, как раз, и доказывает, что модуль был выполнен только один раз.
Если же нам нужно сделать повторный импорт в одной и той же программе, то для этого следует использовать специальную функцию:
importlib.reload(mymodule)
а перед этим импортируем специальный модуль
import importlib
"""

import math
import pprint
import sys
import time

# pprint.pprint(locals())
# pprint.pprint(dir(math))

pprint.pprint(sys.path)
print("-"*50)
pprint.pprint(sys.modules)

