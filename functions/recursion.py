"""Документация по рекурсии функций

Рекурсия — это техника программирования, при которой функция вызывает саму себя,
решая задачу через разбиение её на более простые подзадачи того же типа.

С точки зрения интерпретатора Python, рекурсия — это цепочка обычных вызовов функций,
каждый из которых создаёт новый стек-кадр, до тех пор, пока не будет достигнут базовый случай.

Структура рекурсивной функции

Любая корректная рекурсивная функция обязана содержать два элемента:

Базовый случай (base case)
Условие, при котором рекурсия прекращается и начинается возврат значений.

Рекурсивный шаг (recursive case)
Вызов функции самой себя с более простой версией задачи.

Как рекурсия работает внутри Python

Каждый рекурсивный вызов:

создаёт новый stack frame

имеет свои локальные переменные

Пока вложенный вызов не завершился, текущий вызов приостановлен

Когда достигнут базовый случай:

начинается размотка стека (unwinding)

значения возвращаются вверх по цепочке вызовов

Важно:

Python не оптимизирует хвостовую рекурсию

глубина рекурсии ограничена (sys.getrecursionlimit())

Ключевые свойства рекурсии

Рекурсия не хранит состояние между вызовами, если оно не вынесено во внешнюю структуру

Каждый вызов функции изолирован

Используется стек вызовов, а не куча

Чрезмерная глубина может привести к RecursionError

Когда использовать рекурсию

Рекурсия оправдана, когда:

структура данных рекурсивна (деревья, вложенные списки)

задача естественно описывается через самоподобие

важнее читаемость и концептуальная ясность, чем производительность

Когда НЕ использовать рекурсию

при глубокой вложенности

в производительном коде без необходимости

когда проще использовать цикл

Стек вызова рекурсии — это структура данных, используемая для отслеживания активных вызовов функции,
где каждый новый рекурсивный вызов добавляет (push) контекст (переменные, адрес возврата)
на вершину стека, приостанавливая предыдущий, и убирает (pop) его после завершения.
Он обеспечивает принцип LIFO (последним пришел — первым ушел), позволяя вернуться к незавершенной функции,
пока стек не переполнится.

Ключевые аспекты стека при рекурсии:
Контекст выполнения: Каждый вызов функции — это «кадр» (frame) в памяти, содержащий локальные переменные и параметры.
Приостановка: Когда функция вызывает саму себя, текущий кадр «замораживается» и сохраняется, а сверху кладется новый, дочерний.
Базовый случай: Стек растет, пока не достигается базовый случай (условие выхода),
после чего он начинает «разворачиваться» (удалять кадры) в обратном порядке.
Переполнение стека (Stack Overflow): Слишком глубокая рекурсия расходует всю память стека, вызывая критическую ошибку.
Стек вызовов — это стопка.

кладёшь тарелку сверху → новый вызов функции

снимаешь верхнюю тарелку → функция завершилась

Нельзя вытащить тарелку из середины — только сверху.

Что такое стек вызовов рекурсии

Когда функция вызывает сама себя, Python:

кладёт “записку” в стопку:

какие у неё аргументы

где она остановилась

запускает следующий вызов

так продолжается, пока не дойдёт до конца (базового случая)

Почему рекурсия “возвращается туда, где остановилась”

Потому что каждая “записка” в стопке знает:

где функция остановилась

что делать с результатом

Python просто читает верхнюю записку и продолжает.

Почему бывает ошибка RecursionError

Потому что:

стек не бесконечный

если тарелок слишком много — всё падает

Одна фраза, чтобы запомнить

Стек вызовов — это стопка “незаконченных функций”.
Рекурсия просто кладёт их одну на другую.

Хвостовая рекурсия — это частный вид рекурсии, при котором рекурсивный вызов является
самой последней операцией в функции.
В отличие от обычной рекурсии, здесь не требуется запоминать промежуточные состояния,
что позволяет компилятору автоматически оптимизировать вызов,
превращая его в итерацию (цикл) и предотвращая переполнение стека.
 Ключевые особенности и преимущества: Экономия памяти: Оптимизация хвостовой
рекурсии (Tail Call Optimization — TCO) позволяет переиспользовать текущий кадр стека, а не создавать новый.
Производительность: Работает так же быстро, как обычный цикл while или for.
Формат: Результат рекурсивного вызова сразу возвращается без дополнительных вычислений.
 Пример (Факториал): Обычная (не хвостовая): n * factorial(n-1) — нужно запомнить \(n\), чтобы умножить позже.
Хвостовая: factorial(n-1, acc * n) — результат вычисления передается дальше, текущий кадр не нужен.
 Хвостовая рекурсия часто используется в функциональных языках (Haskell, Scala, Lisp)
и поддерживается некоторыми компиляторами других языков. 
"""

# def factorial(n):
#     if n == 1:
#         return 1
#     return factorial(n - 1) * n
#
#
# print(factorial(10))
#
#
# def fibonacci(x):
#     if x == 1:
#         return 0
#     if x == 2:
#         return 1
#     return fibonacci(x - 1) + fibonacci(x - 2)
#
#
# print(fibonacci(7))
#
#
# def polindrome(s):
#     if len(s) <= 1:
#         return True
#     if s[0] == s[-1]:
#         return polindrome(s[1:-1])
#
#
# print(polindrome("шалаш"))


# def rec(s):
#     if len(s) == 1 or len(s) == 2:
#         return s
#     return s[0] + "(" + rec(s[1:-1]) + ")" +s [-1]
#
#
# print(rec("hello"))


# def power(x, n):
#     if n == 0:
#         return 1
#     if n<0:
#         return 1/power(x, -n)
#     if n%2==0:
#         return power(x, n//2)*power(x, n//2)
#     else:
#         return power(x, n-1)*x
#
#
# x = int(input())
# n = int(input())
# print(power(x, n))
#
#
# print(power(3,-5))


# a = [1, 2, [3, 4, [5], 6], 7, 8, [9, [10]]]


# def sum_nested(lst):
#     s = 0
#     for i in lst:
#         if isinstance(i, int):
#             s += i
#         elif isinstance(i, list):
#             s += sum_nested(i)
#     return s
#
#
# print(sum_nested(a))


# def hm(s: str):
#     if len(s) == 0:
#         return s
#     return s[0] + hm(s[1:]) + s[0].replace("(", ")")
#
#
# print(hm("((t((p((y((kx((((((vw((m(r((kqo"))


# обход файлов
# import os
#
# path = "C:\\Users"
#
#
# def obxodFile(p, level=1):
#     print(f"level={level}", f"content={os.listdir(p)}")
#     for i in os.listdir(p):
#         if os.path.isdir(p+"\\"+i):
#             print("Спускаемся", p + "\\" + i)
#             obxodFile(p + "\\" + i, level + 1)
#             print("Возвращаемся в", p)
#
#
# obxodFile(path)
