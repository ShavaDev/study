"""
функция zip() принимает несколько итерабильных последовательностей, и данная функция вернет нам zip объект
zip объект представляет собой итератор, а значит мы его можем превратить в другую коллекцию

объект итератор, нельзя находить его длину, получать элементы по индексу, элементы итератора можно
итерировать только один раз (обход всех элементов через цикл),
т.к после первого обхода все элементы итератора закончились


1. Итерируемый объект (Iterable)
Это любой объект, из которого можно получить итератор. У него есть метод __iter__().
Примеры: Список (list), строка (str), кортеж (tuple), словарь (dict).
Особенность: Сами по себе они не «помнят», на каком элементе вы остановились.
Вы можете создать из них сколько угодно независимых итераторов.
Аналогия: Книга. В ней есть страницы, её можно читать, но сама книга не знает, на какой странице вы сейчас находитесь.
2. Объект итератора (Iterator)
Это объект, который представляет поток данных. У него есть метод __next__() и метод __iter__().
Пример: То, что возвращает функция iter([1, 2, 3]) или генераторы.
Особенность: Он «помнит» текущее состояние (где он находится в последовательности).
Когда вы вызываете next(), он выдает следующий элемент. Если элементы закончились, он выдает исключение StopIteration.
Важно: Итератор — это «одноразовая» вещь. Как только вы дошли до конца, его нельзя «перезапустить», нужно создавать новый.
Аналогия: Закладка в книге. Она указывает на конкретную страницу. Когда вы переворачиваете страницу, закладка перемещается.

Характеристика	            Итерируемый объект (Iterable)	Итератор (Iterator)
Методы	                    Имеет __iter__	                Имеет __iter__ и __next__
Состояние	                Не хранит состояние обхода	    Хранит текущую позицию
Повторное использование	    Можно обходить многократно	    Одноразовый (после завершения пуст)
Доступ к данным	            Обычно хранит данные в памяти	Часто генерирует данные "на лету"


Когда вы превращаете итератор в коллекцию (например, в список или кортеж),
вы заставляете его «выстрелить» всеми своими значениями сразу и сохранить их в памяти.
Как это происходит:
Вы передаете итератор в конструктор коллекции, например list(my_iterator).
Конструктор внутри себя запускает цикл, вызывает next() до тех пор, пока итератор не исчерпается.
Все полученные элементы сохраняются в новую структуру данных.
Нюансы, о которых важно помнить:
Итератор опустеет: Как только вы преобразовали итератор в список, сам объект итератора станет «пустым».
Если вы попробуете вызвать list(my_iterator) второй раз, вы получите пустой список [].
Память: Итератор может быть бесконечным (например, генератор случайных чисел) или просто очень большим (миллиард строк).
Если вы попытаетесь превратить такой итератор в list, у вас может закончиться оперативная память.
Смена типа: Теперь у вас в руках полноценный итерируемый объект.
Вы можете обращаться к его элементам по индексу my_list[0], чего нельзя было сделать с итератором.

Итератор идеален, когда данных много и вы хотите обрабатывать их по одному, экономя память (принцип «ленивых вычислений»).
Коллекция (list, set) нужна, когда вам важен многократный доступ к данным, сортировка или обращение по индексам.


"""

a = [5, 6, 7, 8]

b = [100, 200, 300, 400]

c = "abcd"

res = zip(a, b, c)
# print(*res) # (5, 100, 'a') (6, 200, 'b') (7, 300, 'c') (8, 400, 'd')
f, g, h = zip(*res)
print(f, g, h)
