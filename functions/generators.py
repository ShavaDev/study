"""
Генератор-выражения - это коллекция, которую можно проитерировать ровно 1 раз

Это происходит потому что элементы генератора не хранятся в памяти все вместе, а формируются на лету,
то есть при каждом новом обращении к переменной внутри цикла либо при помощи функции next() мы сразу получаем
следующий элемент. И это является его большим плюсом, то что все эти элементы не хранятся в памяти.
Он нужен для больших данных, для работы с ними, или для больших вычислений

Функция-генератор - это такая функция, которая возвращает по одному значению, и при этом замораживают свое
выполнение. И при новом вызове, она будет выполняться с того места, на котором она остановилась.
Функция-генератор всегда запоминает какой элемент она в последний раз при помощи инструкции yield возвращала
и какой нужно вернуть следующий

Инструкция yield, она возвращает значение и замораживает функцию во всеми локальными переменными на этом месте
и при обращении к этой функции вновь, она будет запускаться именно со следующей строчки после команды yield


Функция-генератор могут возвращать значение и приостанавливать свою работу,
а позднее продолжить свою работу с места остановки

Для создания функции генератора используется ключевое слово yield.

Генератор - итератор, элементы которого можно итерировать только один раз

Итератор - объект, который поддерживает функцию next(). Помнит о том, какой элемент будет браться следующим

Итерируемый объект - объект, который предоставляет возможность обойти поочередно свои элементы.
Может быть преобразован к итератору.

"""


# a = [i**2 for i in range(1,6)] # генератор списка
#
# b = (i**2 for i in range(1, 6)) # выражение-генератор
#
# # c = list(range(1_000_000_000_000)) # memoryerror
# # но
# g = (i for i in range(1_000_000_000_000))
# for i in g:
#     print(i)


# def gen_f():
#     s = 7
#     for i in range(10):
#         yield i
#         print(s)
#         s = s*10+7
#
# s = gen_f()
# print(next(s))
# print(next(s))
# print(next(s))


def factorial(n):
    pr = 1
    for i in range(1, n + 1):
        print("Пришли наверх, дойдем до генератора, выдадим значение и остановимся")
        pr *= i
        yield pr
        print("Продолжаем функцию после генератора и пойдем сразу наверх")


ans = factorial(5)
print(next(ans))
print(next(ans))
print(next(ans))
print(next(ans))
print(next(ans))

for i in factorial(10):
    print(i, end=" ")


# функция генератор, которая обходит файл и ищет конкретно определенное слово, то есть какой индекс имеет данное слово, когда найдем его
def find_word(file, word):
    """
    Мы здесь в первом цикле читаем файл по строкам. Во втором вложенном цикле while ищем указанное слово в строке,
    используя метод find(). И, если этот метод находит заданный фрагмент, то есть,
    возвращает значение больше -1, то функция генерирует на выходе значение индекса найденного слова как g_index + index.
    Здесь g_index – это смещение по тексту для текущей строки, то есть, в ней мы суммируем длины предыдущих строк,
    чтобы сформировать индекс слова в тексте, а не в строке.
    index определяет индекс вхождения данного слова в эту строку
    :param file:
    :param word:
    :return:
    """
    g_index = 0
    for line in file:
        index = 0
        while index != -1:
            index = line.find(word, index)
            if index > -1:
                yield g_index + index
            index += 1
        g_index += len(line)


try:
    with open("words.txt") as f:
        a = find_word(f, "генератор")
        print(list(a))
except FileNotFoundError:
    print("file not found")
except:
    print("error")
finally:
    print(f.closed)


# задача со степика
from string import ascii_lowercase

letters = ascii_lowercase
gen = (
    a + b
    for a in letters
    for b in letters
)
print(*[next(gen) for _ in range(50)])

# еще одна задачка
cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
gen = (
    cities[i%len(cities)] for i in range(1_000_000)
)
for _ in range(20):
    print(next(gen), end=" ")


# еще одна задачка
import random
from string import ascii_lowercase, ascii_uppercase

# установка зерна датчика случайных чисел (не менять)
random.seed(1)

N = int(input())

chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"

def generator(N):
    while True:                     # генератор БЕСКОНЕЧНЫЙ
        password = ""
        for _ in range(N):
            indx = random.randint(0, len(chars) - 1)
            password += chars[indx]
        yield password              # каждый раз новый пароль

gen = generator(N)

for _ in range(5):
    print(next(gen))