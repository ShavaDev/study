"""
Работа с файлами

Самый простой способ открыть файл — функция open(). Однако в современном Python стандартом является использование оператора with.

Почему with (Context Manager) — это мастхэв?
Обычный вызов f = open() требует обязательного f.close(). Если между открытием и закрытием произойдет ошибка,
файл останется «зависшим» в оперативной памяти, что может привести к утечкам ресурсов.
Менеджер контекста гарантирует закрытие файла автоматически, даже если код упал.

Режимы работы (Modes)При открытии файла важно указать, что именно мы собираемся делать.
Режим   Описание
'r'     Read (Чтение). По умолчанию. Ошибка, если файла нет.
'w'     Write (Запись). Создает новый или полностью перезаписывает старый.
'a'     Append (Дозапись). Добавляет данные в конец файла.
'x'     Exclusive creation. Ошибка, если файл уже существует (защита от перезаписи).
'b'     Binary (Бинарный). Для картинок, видео или байтов.
'rb'    Read Binary. Читаем как сырые байты (нули и единицы) Зачем это нужно?
В текстовом режиме Python может запутаться с кодировками или спецсимволами переноса строки,
когда мы пытаемся «прыгать» по файлу. Для точного перемещения по байтам нужен именно бинарный режим.
'+'     Updating. Позволяет и читать, и писать одновременно (например, 'r+').

Методы, параметры файлов
1) file.read() считывает данные с файла, можно передать сколько символов нужно считать, однако
питон это запомнит и в следующий раз будет считывать с того места где закончил
2) file.seek(смещение, откуда) принимает число, то есть с какого символа продолжить/начать читать
У параметра откуда (второе число) есть три стандартных значения:

0 — Считать от начала файла (по умолчанию).

1 — Считать от текущей позиции курсора.

2 — Считать от конца файла.
3) file.readline() не принимает параметров, читает одну строчку целиком, также запоминает где остановился
4) file.readlines() не принимает параметров, создает список из строк, которые являются строками из файла
5) file.write() принимает строку или текст, что мы хотим записать в файл
6) writelines(list) записывает список строк
7) f.tell() говорит где сейчас находится курсор (байт от начала)


Буферизация (Buffering)
Когда ты вызываешь f.write("Hello"), данные не записываются на жесткий диск мгновенно. Запись на диск — операция дорогая (медленная). Поэтому Python (и операционная система) используют буфер — временную область в памяти.

Данные копятся в буфере.

Когда буфер заполняется или файл закрывается, происходит flush (сброс) данных на диск.

Ты можешь вызвать f.flush() принудительно, если тебе критично записать данные прямо сейчас, не закрывая файл.


Проблема кодировок (Encoding) и Ошибки
При работе с файлами из разных систем (Windows, Linux) ты столкнешься с битыми символами.
Параметр errors в open() позволяет решить, что делать с "плохими" байтами:

errors='strict': (по умолчанию) выкинет UnicodeDecodeError.

errors='ignore': просто пропустит мусор.

errors='replace': вставит знак вопроса вместо непонятного символа.


Временные файлы (Module tempfile)
Senior-разработчики не создают «мусорные» файлы test1.txt вручную.
Если тебе нужно сохранить данные временно (например, для обработки видео), используй библиотеку tempfile.
Она сама создаст файл с уникальным именем и удалит его сразу после закрытия программы.

"""

from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent
FILES_DIR = BASE_DIR / "files"
FILES_DIR.mkdir(parents=True, exist_ok=True)
FILE_TXT = FILES_DIR / "study.txt"


file = open(FILE_TXT, encoding="utf-8", mode="r")
file_txt = file.read()
print(file_txt)
file.close()
