"""
__new__() магический метод, который вызывается перед созданием объекта класса
__init__() сразу вызывается после создания объекта класса

Частая ошибка новичков — называть его конструктором. На самом деле конструктор в Python — это метод __new__,
который создает сам объект в памяти.
А __init__ вызывается сразу после этого, чтобы «наполнить» уже созданный объект конкретными данными.
__init__ нужен для того, чтобы объект «родился» с определенным набором данных и был готов к выполнению своих методов.
Это фундамент состояния объекта.

Второй метод __init__ не был вызван и, кроме того, если мы распечатаем переменную pt
то увидим значение None, то есть, объект не был создан. Почему так произошло?
В Python магический метод __new__ должен возвращать адрес нового созданного объекта.
А в нашей программе он ничего не возвращает, то есть, значение None, что эквивалентно отказу в создании нового объекта.
Именно поэтому переменная pt принимает значение None.
Но откуда мы его возьмем? Для этого можно вызвать аналогичный метод базового класса и делается это, следующим образом
(момент с super())
Здесь функция super() возвращает ссылку на базовый класс и через нее мы вызываем метод __new__ с одним первым аргументом.
Начиная с версии Python 3, все классы автоматически и неявно наследуются от базового класса object
И уже из этого базового класса мы вызываем метод __new__.
Кстати, если метод __new__ не прописывать в классе Point, то будет автоматически запускаться версия базового класса.
То есть, этот метод всегда вызывается при создании нового объекта.
При необходимости, мы можем его переопределять, добавляя новую логику его работы.
И то же самое относится ко всем магическим методам.
Они всегда существуют у всех классов. Но переопределяем мы лишь те, что необходимо, а остальные работают по умолчанию.
В этом сила базового класса object.
В нем уже существует программный код, общий для всех классов языка Python. Иначе, нам пришлось бы его каждый раз прописывать заново.
Зачем нужны списки параметров *args, **kwargs в методе __new__? Мы, вроде, их нигде не используем? В действительности,
здесь хранятся дополнительные параметры, которые мы можем указывать при создании объекта.
Например, строчка: pt = Point(1, 2) создает объект с двумя числовыми значениями, то есть, *args будет содержать эти два числа.
По идее, мы можем реализовать в методе __new__ какую-либо логику с учетом значений этих аргументов.
Но, в данном случае, просто игнорируем. Используем их дальше в методе __init__ при инициализации объекта.
То есть, аргументы 1 и 2 передаются и в метод __new__ и в метод __init__.


«Как Python понимает, что __new__ вернул то, что нужно?»
1. Механизм проверки (The Instance Check)
На самом деле Python не ограничивает тебя жестко. Метод __new__ может вернуть всё что угодно: число,
строку или объект совершенно другого класса. Но у интерпретатора есть четкий алгоритм:
Когда ты пишешь obj = MyClass(), Python делает следующее:
Вызывает MyClass.__new__.
Получает результат (назовем его res).
Проверка: Он спрашивает: «Является ли res экземпляром MyClass (или его подкласса)?»
Если да: Python говорит: «Окей, это наш парень», и вызывает res.__init__(...).
Если нет: Python говорит: «Странно, мне подсунули что-то левое. Я просто отдам этот объект пользователю как есть,
а __init__ вызывать не буду».

2. Как он узнает тип объекта?
В памяти каждый объект Python — это структура (на языке C она называется PyObject).
В заголовке этой структуры всегда есть указатель на объект-класс, который его создал.
Когда super().__new__(cls) отрабатывает, он создает объект и записывает в его «паспорт» (атрибут __class__) ссылку на твой класс cls.
У объекта pt = Point() есть скрытое поле pt.__class__, которое указывает на Point.
Когда __new__ возвращает объект, Python просто сравнивает: ReturnedObject.__class__ == MyClass?.


Конструктор в Python — это процесс, состоящий из двух этапов: выделение памяти (__new__) и наполнение данными (__init__).

"""


class Point:
    def __new__(cls, *args, **kwargs):
        """
        cls – это ссылка на текущий класс Point, а затем, указываются коллекции из фактических и формальных параметров,
        которые может принимать данная функция. Это стандартное определение метода __new__ в классах.
        В теле функции я просто сделал вывод сообщения и переменной cls.
        :param args:
        :param kwargs:
        """
        print("Вызов __new__ для " + str(cls))
        return super().__new__(cls)

    def __init__(self, x=0, y=0):
        """
        а вот этот self ссылается на создаваемый экземпляр класса, то есть экземпляр класса будет создан
        и данный параметр будет на него ссылаться
        :param x:
        :param y:
        """
        print("Вызов __init__ для " + str(self))
        self.x = x
        self.y = y


pt = Point(1, 2)
print(pt.__class__.__name__)
print(pt)


# патерн проектирования Singleton
class DataBase:
    """
    мы разрабатываем класс для работы с БД. В частности, через него можно будет подключаться к СУБД, читать и записывать
    информацию, закрывать соединение
    И далее полагаем, что в программе должен существовать только один экземпляр этого класса в каждый момент ее работы.
    То есть, одновременно два объекта класса DataBase быть не должно. Чтобы это обеспечить и гарантировать,
    как раз и используется паттерн Singleton.
    __instance хранит ссылку на экземпляр этого класса. Если экземпляра нет, то атрибут будет принимать значение None.

    """
    __instance = None  # ссылка на экземпляр класса

    def __new__(cls, *args, **kwargs):
        """
        Мы проверяем атрибут класса __instance. Причем, для обращения к нему используем параметр
        cls – ссылку на текущий класс. Подробнее я еще освещу этот момент. Далее, проверяем, если значение равно None,
        то вызываем метод __new__ базового класса и тем самым разрешаем создание объекта.
        Иначе, просто возвращаем ссылку на ранее созданный экземпляр.
        :param args:
        :param kwargs:
        """
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)

        return cls.__instance

    def __del__(self):
        """
        магический метод – финализатор __del__, который будет обнулять атрибут __instance перед уничтожением объекта,
        чтобы мы могли, при необходимости, создать новый.
        :return:
        """
        DataBase.__instance = None

    def __init__(self, user, password, port):
        self.user = user
        self.password = password
        self.port = port

    def connect(self):
        print(f"Соединение с БД: {self.user}, {self.password}, {self.port}")

    def close(self):
        print("Закрытие соединения с БД")

    def read(self):
        return "данные из БД"

    def write(self, data):
        print(f"Запись в БД: {data}")


db = DataBase("user", "password", "port")
db2 = DataBase("user2", "password2", "port2")
print(id(db))
print(id(db2))
db.connect() # вывод метода одинаковый
db2.connect() # вывод метода одинаковый


# проверка на айди
class Test:
    def __new__(cls):
        obj = super().__new__(cls)
        print(f"ID класса (cls):   {id(cls)}")
        print(f"ID созданного объекта: {id(obj)}")
        return obj

    def __init__(self):
        print(f"ID внутри init (self): {id(self)}")

t1 = Test()