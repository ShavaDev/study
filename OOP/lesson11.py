"""


Комментарий 1
Заморочился и разобрался в данной теме. Вот объяснение, единственное в геттер добавил проверку на вызов на прямую, т.е через экземпляр дескриптора:
if instance is None:
            return self
Теперь если вызвать экземпляр дескриптора (а когда вызываем через класс то вызывается именно он, а не атрибут экземпляра класса, т.е p)
print(Point3D.x); print(Point3D.x.__dict__)

Объяснение. _set_name_ в дескрипторе по сути что и _init_ для обычного класса. При создании экземпляров дескриптора в классе Point3D автоматически вызывается _set_name_ класса дескриптора, он принимает 2 аргумента, класс-владелец, т.е Point3D и name - имя самого экземпляра дескриптора как строку. В _set_name_ создаются по 1 защищённому атрибуту для каждого экземпляра дескриптора. Дальше при создании экземпляра класса Point3D и передачи в _init_ параметров, вызывается _set__(сеттер) который принимает 2 аргумента, экземпляр класса Point3D и значение которое присваивается в конструкторе в экземпляре Point3D. Происходит проверка self.verify_coord(value) в которой значения которые будут присваиваться проверяются на тип int, если проверка успешна то с помощью функции setattr, в пространстве имён экземпляра класса Point3D(в данном случае p) добавляется пара ключ:значение (__dict__) значение это атрибут созданный в  __set_name_ , ключ это то что присваивается в конструкторе экземпляра Point3D после = равенств. Когда функция print() вызывает из экземпляра p, 1 из атрибутов x,y,z то срабатывает __get__(геттер) который сначала проверяет, атрибут был вызван из экземпляра или напрямую, если в геттере instance = None (т.е вызов был не через экземпляр) то возвращается экземпляр дескриптора который имеет в себе атрибут 'name':_x (например), если вызов происходит через экземпляр то возвращается значение из функции getattr которая принимает экземпляр класса(его область видимости имён) и имя атрибута (ключ) и возвращает значение атрибута (ключа).


Комментарий 2
Чтобы понять эту тему, надо прочитать определение этого слова, хотя бы из википедии. Без этого трудно осознать, что творится на экране. Незнакомое слово, ассоциаций к нему нет, а значит все объяснение автора приходится цеплять к мысленной конструкции сферического коня в вакуме. И даже повторения не помогут особо, пока мозг не попробует сам придумать, с чем это связать. Предлагаю не мучиться.
Вот это слово - Дескри́птор (от лат. descriptor «описывающий») . Запомнили?  Далее, это лексическая единица (СЛОВО, СЛОВОСОЧЕТАНИЕ) информационно-поискового языка, служащая для описания основного СМЫСЛового содержания документа, или для поиска. Вот вам и смысловой ряд: ДЕСКРИПТОР - ОПИСЫВАЮЩЕЕ СМЫСЛ СЛОВО, СЛОВОСОЧЕТАНИЕ. Все сразу становиться понятнее:
1. Создаем класс, описывающий логику для доступа к свойствам или для установки нового значения. Типа сеттеров, гетеров, разных проверок и т.д. Что угодно, что является общим для свойств разных объектов. Тут главный момент, что объекты могут принадлежать вообще разным классам. Но они все будут использовать этот класс-дескриптор, который мы создаем на этом шаге, чтобы обрабатывать свои свойства.
2. Создаем любые нужные нам классы. Создаем в них свойства. Смотрим, видим, что некоторые свойства можно обработать, превратив их в дескриптор.  Для этого делаем так, чтобы эти свойства стали экземпляром класса-дескриптора:
property1 = DescriptorClassName()
property2 = DescriptorClassName()
Готово! Мы превратили property1 и property2 в дескрипторы нашего класса!
3. А дальше пользуемся созданными классами как планировали. И когда будем обращаться к свойству-дескриптору property1, например так:
a = MyClass(5)
b = a.property1
то у нас будет вызываться код из класса дескриптора, который обработает цифру 5 так, как это описано в классе дескрипторе.

Основная килл-фича тут в том, что это не наследование, а просто такой крутой способ сократить кучу кода. Не зря в примере у автора используется такое название класса-дескриптора, как  Integer (это моя догадка). Чтобы у нас аналогия появилась. Вы же используете тип int в разных классах, функциях. А если попробуете поработать с int как со строкой, то получите ошибку. Потому что у int типа есть свои внутренние проверки (как это делает класс-дескриптор). В общем, урок отличный. Большой спасибо автору, особенно за такие "хлебные крошки", скрытые подсказки как названия классов в объяснении

_del_ это финализатор, в дескрипторах используются _delete_

Дескриптор - это управляющая структура, а не конкретное значение. То есть, мы его сначала создаем (в целом, как объект), а затем, через этот объект можно назначать и считывать величины, которые будут заноситься в объекты, из которых они вызваны.
"""

# дескриптор не данных
class ReadIntX:
    def __set_name__(self, owner, name):
        self.name = "_x"

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    # def __set__(self, instance, value):
    #     setattr(instance, self.name, value)


# дескриптор данных
class Integer:
    @classmethod
    def varify_coordinate(cls, coordinate):
        if not isinstance(coordinate, int):
            raise TypeError('Coordinate must be an integer')

    def __set_name__(self, owner, name):
        self.name = "_" + name
        # self.name = name # вызывает рекурсию ??

    def __get__(self, instance, owner):
        # return instance.__dict__[self.name]
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        print(f"__set__: {self.name} = {value}")
        self.varify_coordinate(value)
        # instance.__dict__[self.name] = value
        setattr(instance, self.name, value)


class Point3D:
    x = Integer()
    y = Integer()
    z = Integer()
    xr = ReadIntX()

    def __init__(self, x, y, z):
        # self._x = x
        # self._y = y
        # self._z = z

        self.x = x
        self.y = y
        self.z = z

    # @classmethod
    # def varify_coordinate(cls, coordinate):
    #     if not isinstance(coordinate, int):
    #         raise TypeError('Coordinate must be an integer')

    # @property
    # def x(self):
    #     return self._x
    #
    # @x.setter
    # def x(self, value):
    #     self.varify_coordinate(value)
    #     self._x = value
    #
    # @property
    # def y(self):
    #     return self._y
    #
    # @y.setter
    # def y(self, value):
    #     self.varify_coordinate(value)
    #     self._y = value
    #
    # @property
    # def z(self):
    #     return self._z
    #
    # @z.setter
    # def z(self, value):
    #     self.varify_coordinate(value)
    #     self._z = value


p = Point3D(1, 2, 3)
print(p.xr, p.__dict__)