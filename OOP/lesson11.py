"""
В классе Point3D получилось своеобразное дублирование: мы три раза прописывали свойства, фактически,
с одинаковым функционалом. Менялись только названия методов и локальных атрибутов.
Представьте, во что превратится описание этого класса, если нужно будет задать 10 и более таких объектов-свойств!
Программист во всем этом просто запутается, да и редактировать такую программу станет непросто.
Как можно все это оптимизировать? Здесь нам на помощь как раз и приходят дескрипторы.

Дескриптор — это объект (класс), который определяет поведение доступа к атрибуту другого объекта.
Чтобы класс стал дескриптором, в нем должен быть реализован хотя бы один из магических методов:
 __get__, __set__ или __delete__.

Вначале, что вообще такое дескрипторы? Это класс, который содержит или один магический метод __get__:

class A:
    def __get__(self, instance, owner):
        return ...
Или класс, в котором дополнительно прописаны методы __set__ и/или __del__:

class B:
    def __get__(self, instance, owner):
        return ...

    def __set__(self, instance, value):
        ...

    def __del__(self):

Первый (класс A) называется non-data descriptor (дескриптор не данных),
а второй (класс B) – data descriptor (дескриптор данных). Это различие имеет смысл

Data descriptors (Дескрипторы данных): Имеют и __get__, и __set__.
Они имеют приоритет над словарем объекта __dict__. Если ты обратишься к атрибуту, Python сначала пойдет в дескриптор.
------------------------------------------------------------------------------------------------------------------------
Non-data descriptors: Имеют только __get__ (например, обычные методы класса).
Если в __dict__ объекта уже есть такое имя, Python возьмет значение из словаря, проигнорировав дескриптор.


В классе Point3D мы создадим три атрибута как объекты класса Integer
x = Integer()
y = Integer()
z = Integer()
Эти атрибуты и есть дескрипторы данных, через которые будет проходить взаимодействие.
Итак, когда мы создавали экземпляры классов Integer, то автоматически вызывался магический метод __set_name__,
в котором параметр self являлся ссылкой на создаваемый экземпляр класса; owner – ссылка на класс Point3D;
name – имя атрибута (для первого объекта x, затем, y и z).
В этом методе мы формируем локальное свойство с именем атрибута, добавляя перед ним одно нижнее подчеркивание
(так принято делать при определении дескрипторов). В итоге, в экземплярах классов будут храниться имена _x, _y, _z.
Предположим, мы создаем экземпляр класса Point3D:
pt = Point3D(1, 2, 3)
Сработает инициализатор, а в нем идет обращение к дескрипторам x, y, z.
В частности, мы им присваиваем переданные значения. В этом случае, в классе Integer срабатывает сеттер
(магический метод __set__), параметр self – это ссылка на объект дескриптора; instance – ссылка на объект pt,
из которого произошло обращение к дескриптору; value – присваиваемое значение.
В этом сеттере мы выводим в консоль сообщение, что был вызван данный метод и отображаем сохраненное имя
и присваиваемое значение. Следующей строчкой через ссылку instance, то есть, на экземпляр класса pt,
формируем в нем локальное свойство с именем self.name и присваиваем значение value.
В результате, в объекте pt появляются локальные свойства _x, _y, _z с соответствующими значениями.
Если затем, выполнить считывание данных через дескриптор, например, x,
то автоматически сработает геттер (метод __get__), в котором self – это ссылка на объект Integer;
instance – ссылка на экземпляр класса pt; owner – ссылка на класс Point3D.
Мы здесь через ссылку instance обращаемся к словарю __dict__ и считываем значение нужного локального свойства,
которое, затем, возвращается геттером. Это же значение автоматически возвращается и самим дескриптором.

Теперь вернемся к тому, что вначале я вам говорил, что важно различать дескрипторы данных и не данных.
В чем разница? Ну, во-первых, очевидно, дескрипторы не данных не могут менять значения какого-либо свойства,
так как не имеют сеттера и делитера. Они служат только для считывания информации. И есть второе важное отличие.
Они имеют тот же приоритет доступа, что и обычные атрибуты класса.
Добавим в программу еще один дескриптор, только не данных
Он у нас будет считывать локальное свойство _x. Определим его в классе Point3D:
    xr = ReadIntX()
И теперь можем использовать для считывания локального атрибута _x:
print(pt.xr)
Как видите, все работает. Но, что будет, если мы запишем конструкцию:
pt.xr = 5
Произойдет ошибка? Нет! В экземпляре pt будет создано новое локальное свойство с именем xr и мы в этом можем убедиться:
print(pt.xr, pt.__dict__)
Кроме того, при обращении к pt.xr мы получаем значение 5, а не 1. Это, как раз и говорит о том,
что приоритет доступа к локальным свойствам объекта и к дескриптору не данных одинаков.
Однако, если в дескриптор добавить сеттер и превратить его в дескриптор данных, добавим магический метод __set__
А создание локального атрибута xr в объекте pt мы сделаем через коллекцию __dict__:
pt.__dict__['xr'] = 5
то при выполнении:
print(pt.xr, pt.__dict__)
увидим значение 1, хотя в объекте существует свойство xr.
Это произошло потому, что приоритет обращению к дескриптору данных выше, чем к локальным атрибутам экземпляра класса.
То есть, здесь все работает ровно так, как и с доступом к объектам-свойствам,



------------------------------------------------------------------------------------------------------------------------
КОММЕНТАРИИ

Комментарий 1
Заморочился и разобрался в данной теме. Вот объяснение, единственное в геттер добавил проверку на вызов на прямую,
т.е через экземпляр дескриптора:
if instance is None:
    return self
Теперь если вызвать экземпляр дескриптора (а когда вызываем через класс то вызывается именно он,
а не атрибут экземпляра класса, т.е p)
print(Point3D.x); print(Point3D.x.__dict__)

Объяснение. _set_name_ в дескрипторе по сути что и _init_ для обычного класса.
При создании экземпляров дескриптора в классе Point3D автоматически вызывается _set_name_ класса дескриптора,
он принимает 2 аргумента, класс-владелец, т.е Point3D и name - имя самого экземпляра дескриптора как строку.
В _set_name_ создаются по 1 защищённому атрибуту для каждого экземпляра дескриптора.
Дальше при создании экземпляра класса Point3D и передачи в _init_ параметров, вызывается __set__(сеттер)
который принимает 2 аргумента, экземпляр класса Point3D и значение которое присваивается в конструкторе
в экземпляре Point3D. Происходит проверка self.verify_coord(value) в которой значения которые будут
присваиваться проверяются на тип int, если проверка успешна то с помощью функции setattr,
в пространстве имён экземпляра класса Point3D(в данном случае p) добавляется пара ключ:значение (__dict__) з
начение это атрибут созданный в  __set_name_ , ключ это то что присваивается в конструкторе
экземпляра Point3D после = равенств. Когда функция print() вызывает из экземпляра p,
1 из атрибутов x,y,z то срабатывает __get__(геттер) который сначала проверяет,
атрибут был вызван из экземпляра или напрямую, если в геттере instance = None (т.е вызов был не через экземпляр)
то возвращается экземпляр дескриптора который имеет в себе атрибут 'name':_x (например),
если вызов происходит через экземпляр то возвращается значение из функции getattr которая
принимает экземпляр класса(его область видимости имён) и имя атрибута (ключ) и возвращает значение атрибута (ключа).


Комментарий 2
Чтобы понять эту тему, надо прочитать определение этого слова, хотя бы из википедии.
Без этого трудно осознать, что творится на экране. Незнакомое слово, ассоциаций к нему нет,
а значит все объяснение автора приходится цеплять к мысленной конструкции сферического коня в вакуме.
И даже повторения не помогут особо, пока мозг не попробует сам придумать, с чем это связать. Предлагаю не мучиться.
Вот это слово - Дескри́птор (от лат. descriptor «описывающий») .
Запомнили?  Далее, это лексическая единица (СЛОВО, СЛОВОСОЧЕТАНИЕ) информационно-поискового языка,
служащая для описания основного СМЫСЛового содержания документа, или для поиска. Вот вам и смысловой ряд:
ДЕСКРИПТОР - ОПИСЫВАЮЩЕЕ СМЫСЛ СЛОВО, СЛОВОСОЧЕТАНИЕ. Все сразу становиться понятнее:
1. Создаем класс, описывающий логику для доступа к свойствам или для установки нового значения.
Типа сеттеров, гетеров, разных проверок и т.д. Что угодно, что является общим для свойств разных объектов.
Тут главный момент, что объекты могут принадлежать вообще разным классам.
Но они все будут использовать этот класс-дескриптор, который мы создаем на этом шаге, чтобы обрабатывать свои свойства.
2. Создаем любые нужные нам классы. Создаем в них свойства. Смотрим, видим, что некоторые свойства можно обработать,
превратив их в дескриптор.  Для этого делаем так, чтобы эти свойства стали экземпляром класса-дескриптора:
property1 = DescriptorClassName()
property2 = DescriptorClassName()
Готово! Мы превратили property1 и property2 в дескрипторы нашего класса!
3. А дальше пользуемся созданными классами как планировали. И когда будем обращаться к свойству-дескриптору property1,
например так:
a = MyClass(5)
b = a.property1
то у нас будет вызываться код из класса дескриптора, который обработает цифру 5 так,
как это описано в классе дескрипторе.

Основная килл-фича тут в том, что это не наследование, а просто такой крутой способ сократить кучу кода.
Не зря в примере у автора используется такое название класса-дескриптора, как  Integer (это моя догадка).
Чтобы у нас аналогия появилась. Вы же используете тип int в разных классах, функциях.
А если попробуете поработать с int как со строкой, то получите ошибку.
Потому что у int типа есть свои внутренние проверки (как это делает класс-дескриптор). В общем, урок отличный.
Большой спасибо автору, особенно за такие "хлебные крошки", скрытые подсказки как названия классов в объяснении

_del_ это финализатор, в дескрипторах используются _delete_

Дескриптор - это управляющая структура, а не конкретное значение. Т
о есть, мы его сначала создаем (в целом, как объект), а затем, через этот объект можно назначать и считывать величины,
которые будут заноситься в объекты, из которых они вызваны.
"""


# дескриптор не данных
class ReadIntX:
    def __set_name__(self, owner, name):
        self.name = "_x"

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    # def __set__(self, instance, value):
    #     setattr(instance, self.name, value)


# дескриптор данных
class Integer:
    """
    В классе Integer я сделаю обращение к атрибутам экземпляра через стандартные функции getattr и setattr
    Так будет правильнее, с точки зрения Python, чем обращение напрямую к специальной коллекции __dict__.
    """

    @classmethod
    def varify_coordinate(cls, coordinate):
        if not isinstance(coordinate, int):
            raise TypeError('Coordinate must be an integer')

    def __set_name__(self, owner, name):
        """
        Как работает рекурсия, точнее почему она происходит?

        В __init__ вызывается self.x = 1.

        Python видит: «Ага, в классе Point3D для атрибута x назначен дескриптор данных Integer. Вызываю его метод __set__».

        Заходим в Integer.__set__(self, instance, 1):

        Ты внутри вызываешь setattr(instance, self.name, 1).

        Но self.name у нас равно "x"!

        То есть команда превращается в setattr(instance, "x", 1).

        Внимание: setattr(instance, "x", 1) — это то же самое, что и instance.x = 1.

        Python снова видит попытку записи в x, снова видит дескриптор и снова вызывает Integer.__set__.

        Цикл замкнулся. Ты внутри метода __set__ для x вызываешь команду, которая снова триггерит этот же __set__ для x.

        Как подчеркивание это лечит:
        Когда ты пишешь self.name = "_x", внутри метода __set__ команда превращается в setattr(instance, "_x", 1).
        Python смотрит: «Так, для имени "_x" в классе Point3D дескриптор назначен? Нет! (он назначен только для x, y, z)».
        Раз дескриптора нет, Python просто берет и записывает число 1 в словарь объекта под ключом _x. Рекурсия разорвана.
        :param owner:
        :param name:
        :return:
        """
        print(f"!!! Магия: связываю дескриптор с именем {name} в классе {owner.__name__}")
        self.name = "_" + name
        print(self.__dict__)
        # self.name = name # вызывает рекурсию ??

    def __get__(self, instance, owner):
        # return instance.__dict__[self.name]
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        print(f"__set__: {self.name} = {value}")
        self.varify_coordinate(value)
        # instance.__dict__[self.name] = value
        setattr(instance, self.name, value)


class Point3D:
    x = Integer()  # дескриптор данных
    y = Integer()  # дескриптор данных
    z = Integer()  # дескриптор данных
    xr = ReadIntX()  # не дескриптор данных

    def __init__(self, x, y, z):
        # self._x = x
        # self._y = y
        # self._z = z

        self.x = x
        self.y = y
        self.z = z

    # @classmethod
    # def varify_coordinate(cls, coordinate):
    #     if not isinstance(coordinate, int):
    #         raise TypeError('Coordinate must be an integer')

    # @property
    # def x(self):
    #     return self._x
    #
    # @x.setter
    # def x(self, value):
    #     self.varify_coordinate(value)
    #     self._x = value
    #
    # @property
    # def y(self):
    #     return self._y
    #
    # @y.setter
    # def y(self, value):
    #     self.varify_coordinate(value)
    #     self._y = value
    #
    # @property
    # def z(self):
    #     return self._z
    #
    # @z.setter
    # def z(self, value):
    #     self.varify_coordinate(value)
    #     self._z = value


p = Point3D(1, 2, 3, )
p.__dict__["xr"] = 5
print(p.xr, p.__dict__)
