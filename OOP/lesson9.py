"""
PROPERTY

Что такое "Объект-свойство" (Property)?
В обычном понимании у объекта есть методы (что он делает) и атрибуты (что он хранит).
Свойство (@property) — это гибрид. Внешне оно выглядит как обычный атрибут (ты пишешь p.age = 20), но внутри это вызов метода


Нам нужно прописывать разные сеттеры и геттеры для разных приватных атрибутов экземпляров класса.
Например, добавить еще два для имени. В результате, пользователю этого класса (программисту)
придется запоминать и держать в голове названия имен всех этих сеттеров и геттеров.
Как можно было бы упростить работу с таким классом? Один из способов – воспользоваться объектом property.
Давайте посмотрим на конкретном нашем примере, как это можно сделать.

В самом классе Person мы пропишем атрибут и придумаем ему имя, допустим, age.
Этот атрибут класса будет ссылаться на объект property, которому мы передадим ссылку на геттер и сеттер:
age = property(get_age, set_age)
Что у нас тут с вами получилось? Смотрите. Из каждого экземпляра класса мы совершенно спокойно можем
обращаться к атрибуту класса age. Этот атрибут является объектом property.
Данный объект так устроен, что при считывании данных он вызывает первый метод get_age,
этот метод возвращает значение приватного локального свойства __age экземпляра класса p и именно это значение
дальше возвращается атрибутом age. Поэтому переменная a будет ссылаться на значение текущего возраста сотрудника.
Если же мы обращаемся к атрибуту класса age и присваиваем ему какое-то значение:
p.age = 35
то автоматически вызывается второй метод set_age и в локальное свойство __age заносится значение,
указанное после оператора присваивания. В итоге, в текущем объекте p меняется локальное свойство __age на новое.

Почему строчка:
p.age = 35
не создает новое локальное свойство внутри объекта p, как это у нас было ранее в программах,
а обращается именно к атрибуту класса Person? Все дело в приоритете.
Если в классе задан атрибут как объект-свойство, то в первую очередь выбирается оно, даже если
в экземпляре класса есть локальное свойство с таким же именем. В этом легко убедиться.
Давайте создадим свойство с именем age прямо в объекте p через словарь __dict__:
p.__dict__['age'] = 'age in object p'
А, затем выведем всю информацию в консоль:
print(p.age, p.__dict__)
Отображается значение 35, а не строка, то есть, было обращение именно к объекту-свойству age класса Person.
А если свойству age в классе присвоить, какое-либо числовое значение, например, то будет отображена строка из объекта p.
Здесь уже срабатывают знакомые нам приоритеты: сначала локальная область видимости объекта, затем, класса.
Вот этот момент нужно хорошо знать, при работе с объектами-свойствами.
Итак, теперь у нас есть класс и мы можем менять приватное свойство __age экземпляров этого класса
через единый атрибут age (считывать информацию и записывать). Это гораздо удобнее использования сеттеров и геттеров.
Здесь всего один атрибут и через него естественным образом происходит взаимодействие с закрытым свойством __age.


Декоратор @property
Однако, в нашей реализации есть некое функциональное дублирование: мы можем работать с приватным свойством __age
и через сеттер/геттер и через свойство класса age. Конечно, это не критичный момент и на него можно не обращать внимания.
Но, на мой взгляд было бы лучше, если бы у нас был один интерфейс взаимодействия со свойством __age.
Как это можно сделать?
Вот этот класс property позволяет нам на уровне его объектов, использовать функции-декораторы. Если в консоли прописать:
a = property()
то через ссылку a нам будут доступны эти самые функции:
a.getter() – декоратор для сеттера;
a.setter() – декоратор для геттера;
a.deleter() – декоратор для делитера.

То есть, вот эту строчку:
age = property(get_age, set_age)
можно переписать и так:
    age = property()
    age = age.setter(set_age)
    age = age.getter(get_age)

Это будет одно и то же. При вызове метода setter осуществляется встраиванием метода set_age
в алгоритм работы объекта property. И то же самое делает метод getter только для геттера.
В обоих случаях они возвращают ссылку на объект property, который мы должны сохранять.

Так вот, мы можем использовать эти декораторы, чтобы сразу нужный нам метод класса превратить
в объект-свойство property. Делается это очень просто. Перед геттером (обратите внимание, именно перед геттером,
а не сеттером или делитером) прописывается декоратор:
    @property

По идее, он теперь представляет объект-свойство с именем get_age:
print(p.get_age)

Но пока присваивание не работает:
p.get_age = 35
так как мы не прописали декоратор для сеттера. Делается это просто.
Метод set_age нужно переименовать в get_age, чтобы имена совпадали (это обязательное условие), потому что у нас
объект-свойство property это get_age
и перед ним прописать декоратор:
    @get_age.setter
так как get_age это объект-свойство property и у него есть декоратор setter

Все, мы сформировали новый объект-свойство с именем get_age. Давайте его переименуем просто в age

То, что мы сделали, эквивалентно предыдущему варианту с тем лишь отличием, что теперь напрямую вызывать
сеттер или геттер для локального свойства __age не получится. У нас остался один интерфейс
взаимодействия – объект-свойство age. Именно так чаще всего делают на практике.
"""

class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    @property
    def age(self): # get_age
        return self.__age

    @age.setter
    def age(self, age): # set_age
        self.__age = age

    @age.deleter
    def age(self): # del_age
        """
        дилетер для свойства age, данный метод вызывается когда происходит удаление определенного свойства
        при удалении свойства age конструкцией del p.age на самом деле вызывется этот делитер и будет и будет
        удалено приватное свойство __age из экземпляра класса
        :return:
        """
        del self.__age

    # age = property()
    # age = age.setter(set_age)
    # age = age.getter(get_age)
    # age = age.deleter(del_age)

p = Person("John", 20)
a = p.age
p.age = 35
del p.age
print(p.__dict__)
p.age = 15
print(p.__dict__)

# import pprint
# pprint.pprint(locals())