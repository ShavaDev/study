"""
МЕХАНИЗМ ИНКАПСУЛЯЦИИ

Пришла пора сделать следующий шаг и познакомиться с механизмом ограничения доступа к данным и методам класса извне.
Это основа механизма инкапсуляции.

Когда создается экземпляр этого класса, то имеется полный доступ ко всем его локальным атрибутам,
а, значит, их всегда можно изменить через ссылку pt и присвоить любые значения, в том числе и недопустимые (например, строку).

Так вот, чтобы указать программисту (пользователю класса), чтобы он не обращался напрямую к атрибутам, их следует делать
«закрытыми». Что это такое? Смотрите, в Python возможны следующие варианты доступа к данным:
attribute (без одного или двух подчеркиваний вначале) – публичное свойство (public);
_attribute (с одним подчеркиванием) – режим доступа protected (служит для обращения внутри класса и во всех его дочерних классах)
__attribute (с двумя подчеркиваниями) – режим доступа private (служит для обращения только внутри класса).


Так реализуется режим protected в Python. Если кто из вас программирует на других языках, например, С++ или Java,
то сейчас ожидают, что мы не сможем обращаться к свойствам _x и _y через ссылку pt, так как они определены как
защищенные (protected). Давайте проверим и попробуем вывести их в консоль.
Как видим, никаких ошибок не возникает и все работает так, словно это публичные свойства экземпляра класса.
Но тогда зачем нам писать это нижнее подчеркивание, если оно не играет никакой роли? Одна роль у этого префикса
все-таки есть: нижнее подчеркивание должно предостерегать программиста от использования этого свойства вне класса.
Впоследствии это может стать причиной непредвиденных ошибок. Например, изменится версия класса и такое свойство может
перестать существовать, т.к. никто не предполагал доступа к нему извне. Так что, к таким атрибутам лучше не обращаться
напрямую – одно нижнее подчеркивание указывает нам, что это внутренние, служебные переменные.


Давайте теперь посмотрим, как работает режим доступа private. Пропишем у локальных свойств два подчеркивания
и также попробуем обратиться к ним напрямую
После запуска программы видим ошибку, что такие свойства не определены. Это говорит о том, что извне, через переменную pt
мы не можем напрямую к ним обращаться. А вот внутри класса доступ к ним открыт.
Пропишем метод set_coord, который будет менять локальные свойства __x и __y экземпляра класса
А ниже, вызовем его для экземпляра pt
Как видите, никаких ошибок не возникает и чтобы убедиться в изменении локальных приватных свойств, определим еще один метод
get_сoord, и вызовем его, После запуска программы видим измененные координаты точки.
В результате, мы с вами определили два вспомогательных метода: set_coord и get_coord, через которые предполагается
работа с защищенными данными класса. Такие методы в ООП называются сеттерами и геттерами или еще интерфейсными методами.

Класс в ООП следует воспринимать как некое единое целое, и чтобы случайно или намеренно не нарушить целостность работы
алгоритма внутри этого класса, то следует взаимодействовать с ним только через публичные свойства и методы.
В этом суть принципа инкапсуляции.
Можно сказать и о программисте, который намеренно обходит запрет и обращается к скрытым атрибутам класса напрямую,
а не через сеттеры или геттеры. Так делать не нужно.

Назначение интерфейсных методов не только передавать значения между приватными атрибутами класса, но и проверять их
корректность. Например, в нашем случае координаты должны быть числами. Поэтому, прежде чем обновлять значения
переменных, следует проверить их тип данных. Для этого можно воспользоваться функцией type и записать сеттер


На самом деле, в Python можно относительно легко обратиться и к приватным атрибутам извне. Если распечатать все атрибуты экземпляра
'_Point__x', '_Point__y'
Это и есть кодовые имена приватных атрибутов, к которым мы можем обратиться через ссылку pt
и менять их. Однако, так делать крайне не рекомендуется и двойное подчеркивание должно сигнализировать программисту,
что работать с такими атрибутами нужно только через разрешенные интерфейсные методы. Иначе, возможны непредвиденные ошибки.


Если у вас появилась необходимость лучше защитить методы класса от доступа извне, то это можно сделать с помощью модуля accessify
И, затем, импортировать из него два декоратора: private, protected
Далее, нужный декоратор просто применяем к методу и он становится либо приватным (private), либо защищенным (protected)
Все, теперь мы можем обратиться к check_value только внутри класса, но не извне



Privat методы - это обработчики для гетеров, сетеров и прочих функций (например, проверка,
чтобы str значение не записывали туда, где цифры)
Privat свойства - это переменные  (часто это константы), которые нельзя менять просто так.
Только внутриклассовыми методами.
Privat атрибуты защищены от случайного вызова снаружи класса (они недоступны). Рассчитаны только на использование
внутри класса и только внутри, без наследования и т.п.

Protect свойства и методы - это служебные атрибуты класса, использовать можно снаружи, но на свой страх и риск,
т.к. их могут изменить другие разработчики в любой момент.
Protect свойства и методы  - рассчитаны на использование как в классе, так и для наследования в другие классы.
"""

from accessify import private, protected

class Point:
    def __init__(self, x=0, y=0):
        self.__x = self.__y = 0

        if self.__check_value(x) and self.__check_value(y):
            self.__x = x
            self.__y = y

    # @private
    @classmethod
    def __check_value(cls, arg): # если использую @private, то __ уже не нужно
        """
        Продолжим совершенствовать наш класс Point и добавим приватный метод
        для проверки корректности координат. Приватный метод объявляется также как и
        приватная переменная – двумя подчеркиваниями и, кроме того, сделаем его методом уровня класса
        Запускаем программу и видим, что все работает. Но, при этом, доступа к этому методу извне нет, он приватный
        :param arg:
        :return:
        """
        return type(arg) in [int, float]

    def set_coords(self, x, y):
        """
        Здесь мы проверяем, что обе переданные переменные x и y должны иметь тип int или float
        и только после этого приватным атрибутам экземпляра класса присваиваются новые значения.
        Иначе, генерируется исключение ValueError.
        :param x:
        :param y:
        :return:
        """
        # if type(x) in [int, float] and type(y) in [int, float]:
        if self.__check_value(x) and self.__check_value(y):
            self.__x = x
            self.__y = y
        else:
            raise ValueError("Координты должны быть числами!")


    def get_coords(self):
        return self.__x, self.__y


pt = Point(10, 20)
pt.set_coords(100, 200)
print(pt.get_coords())
print(pt.__dict__)
print(dir(pt))
print(pt._Point__x)
print(pt._Point__y)
pt.check_value(5)
