"""
В каждом классе есть магические методы (__магический метод__)
__init__(self) инициализатор объекта класса, вызывается сразу после создания экземпляра класса
__del__(self) финализатор класса вызывается перед его удалением

работа с __init__
сначала происходит создание объекта в памяти устройства, и непосредственно перед его созданием вызывается магический метод
__new__, затем, после успешного создания объекта, вызывается следующий магический метод __init__, и данный метод создает
в нашем случае создает два локальных свойства (x, y), то есть в результате в новом созданном объекте появляются свойства
x и y со значениями 0

работа с __del__
данный метод автоматически вызывается перед уничтожением экземпляра класса и он называется финализатор
Здесь по-прежнему self – это ссылка на экземпляр класса, который будет удален.

После запуска программы видим, что объект в конце программы действительно был удален и вызван метод __del__.
Но, здесь у вас может возникнуть вопрос: а когда и в какой момент вообще происходит удаление объектов.
Мы же в программе это явно нигде не указываем? Работает все достаточно просто. Интерпретатор языка Python имеет,
так называемый, сборщик мусора. Это алгоритм, который отслеживает объекты и как только они становятся ненужными, удаляет их.
Но как он определяет нужный объект или ненужный? Все очень просто. Пока на какой-либо объект ведет хотя бы одна внешняя ссылка,
то он считается используемым и сохраняется в памяти.
Как только все внешние ссылки пропадают, то сборщик мусора его уничтожает (освобождает память, которую он занимал).
"""

class Point:
    color = "red"
    circle = 2

    def __init__(self, a, b):
        print("вызов __init__")
        self.x = a
        self.y = b

    def __del__(self):
        print("Удаление экземпляра " + str(self))

    def set_coords(self, x, y):
        self.x = x
        self.y = y


    def get_coords(self):
        return self.x, self.y


pt = Point(1, 2)
# pt.set_coords(1, 2)
print(pt.__dict__)
cs = pt
del pt
# print(pt) # выйдет ошибка