"""
Паттерное моносостояния

У нас некий многопоточный процесс и в каждом потоке создается свой экземпляр класса ThreadData.
Но нам бы хотелось, чтобы все они имели единые локальные свойства

Обратите внимание, имели бы именно единые локальные свойства, а не просто одни и те же данные,
то есть, их словарь __dict__ был бы одинаков для всех этих экземпляров.

Когда ты пишешь self.x = 10, Python на самом деле делает self.__dict__['x'] = 10

Почему изменения видны у всех?
Потому что переменная __dict__ внутри th1 и th2 — это не копия словаря,
а указатель (ссылка) на одно и то же место в памяти.
Ты меняешь th2.id = 2.
Python идет в th2.__dict__ (который является __shared_attrs) и меняет там значение.
Поскольку th1.__dict__ смотрит туда же, он мгновенно «видит» изменения

В Python любая переменная — это просто указатель (адрес в памяти).
Когда ты создаешь обычный объект, Python выделяет память под "заголовок" объекта.
В этом заголовке есть скрытый указатель на словарь __dict__.

В обычном классе:
Объект 1 (id=100) -> Указывает на Словарь А (id=500)
Объект 2 (id=200) -> Указывает на Словарь Б (id=600)

В паттерне Моносостояние:
Ты создал в классе один общий словарь __shared_attrs (допустим, его адрес в памяти 0x777).
В __init__ ты принудительно сказал: "Эй, объект 1, твой __dict__ теперь живет по адресу 0x777".
"Эй, объект 2, твой __dict__ тоже теперь живет по адресу 0x777".
В итоге: объекты сами по себе разные (разные "заголовки" в памяти),
но когда они хотят посмотреть свои данные, они оба идут в одну и ту же ячейку памяти 0x777

Почему ID словарей одинаковый?
Функция id() в Python (в реализации CPython) возвращает адрес объекта в оперативной памяти.
Когда ты вызываешь id(th1.__dict__), Python:
Идет к объекту th1.
Смотрит, на какой адрес указывает его поле __dict__.
Видит там адрес 0x777.
Когда ты вызываешь id(th2.__dict__), он видит тот же самый адрес. Именно поэтому их ID одинаковы.
Они буквально делят одну и ту же структуру данных в памяти.

А что с атрибутами внутри? (id, name и т.д.)
Тут еще интереснее. Атрибуты id, name, data лежат внутри этого общего словаря.
Когда ты пишешь th1.id, происходит такая цепочка:
th1 -> "Где мой словарь?" -> "По адресу 0x777".
В словаре по адресу 0x777 ищется ключ "id".
Ключ "id" указывает на объект-число 1 (который тоже лежит где-то в памяти, например, по адресу 0x999).
Поэтому id(th1.id) и id(th2.id) будут одинаковыми — они оба в конечном итоге
привели тебя к одному и тому же объекту-числу в памяти.
"""


class ThreadData:
    __shared_attrs = {
        "name": "thread_1",
        "data": {},
        "id": 1
    }

    def __init__(self):
        """
        в инициализаторе этого класса, переопределим специальную коллекцию __dict__
        на общий словарь __shared_attrs. Таким образом, коллекция __dict__ в каждом экземпляре
        будет ссылаться на один и тот же словарь класса __shared_attrs, а значит,
        все они будут иметь общие локальные свойства
        """
        self.__dict__ = self.__shared_attrs


th1 = ThreadData()
print(th1.__dict__)
th2 = ThreadData()
print(th2.__dict__)
th2.id = 2
print(th2.__dict__)
print(th1.__dict__)
th1.new_attr = 'nw-attr'
print(th1.__dict__)
print(th2.__dict__)