"""
МЕТОДЫ КЛАССА

в Python помимо таких «стандартных» методов можно задавать методы уровня класса и статические методы с помощью встроенных
декораторов: @classmethod и @staticmethod

Обратите внимание, у методов класса (когда мы используем декоратор classmethod) первым параметром
идет cls – ссылка на класс, а не self – ссылка на объект класса. Это означает, что данный метод может обращаться только
к атрибутам текущего класса, но не к локальным свойствам его экземпляров. Мало того, этот метод можно теперь напрямую
вызывать из класса, не передавая ссылку на экземпляр, как это было при вызове обычных методов через класс:
res = Vector.validate(5)
Здесь пользователь класса Vector может совершенно спокойно вызывать метод validate(), не создавая никаких объектов.
Но «платой» за это является ограниченность метода: он может работать только с атрибутами класса, но не объекта,
что, в общем то, естественно, так как у него изначально нет ссылки на объект. Во всем остальном этот метод работает
абсолютно также, как и любой другой метод, объявленный в классе.

Наконец, третий тип методов – статические методы, определяются декоратором @staticmethod. Это методы, которые
не имеют доступа ни к атрибутам класса, ни к атрибутам его экземпляров, то есть, некая независимая, самостоятельная
функция, объявленная внутри класса. Обычно, это делают для удобства, т.к. их функционал так или иначе связан с тематикой класса.
Здесь нет никаких скрытых параметров, которые бы автоматически заполнялись интерпретатором языка.
Только те, что мы прописываем сами. Я указал два параметра x, y, по которым вычисляется квадрат длины радиус-вектора.
То есть, это некая вспомогательная, сервисная функция, связанная с векторами, для вычисления квадратичной нормы любого
радиус-вектора. Воспользоваться этим методом можно как вне класса:
res = Vector.norm2(5, 6)
Так и внутри класса.
Либо, также обратиться к этому методу через self


Подведем итог различных типов методов в классах. Обычные методы, как правило, вызываются из экземпляров классов и
работают с атрибутами экземпляров и атрибутами классов. Методы классов обычно вызываются через класс, реже через его
экземпляры и имеют доступ только к атрибутам самого класса, в котором объявлены. Наконец, статические методы – это
совершенно изолированные функции, которые работают только с параметрами, прописанными в ней самой и не имеют доступа к
атрибутам класса или его экземпляров.

Поэтому, если вам нужен метод, который работает с атрибутами объектов класса, то это обычное определение функций
внутри класса с первым параметром self. Если метод работает только с атрибутами класса, то возможно, имеет смысл
его определить как метод класса и тогда можно будет вызывать без ссылки на объект этого класса. Третий тип,
статические методы часто определяют как вспомогательные, сервисные, связанные с логикой работы самого класса.
"""


class Vector:
    MIN_COORDINATES = 0
    MAX_COORDINATES = 100

    @classmethod
    def validate(cls, arg):
        return cls.MIN_COORDINATES <= arg <= cls.MAX_COORDINATES

    def __init__(self, x, y):
        """
        мы здесь обращаемся к методу класса через пространство имен Vector. Но также можем прописать и self
        В этом случае интерпретатор Python сам подставит нужный класс в параметр cls данного метода,
        так как экземпляр содержит информацию о классе, от которого был образован.
        :param x:
        :param y:
        """
        self.x = self.y = 0
        if self.validate(x) and self.validate(y):
        # if Vector.validate(x) and Vector.validate(y):
            self.x = x
            self.y = y
        print(Vector.norm2(self.x, self.y))
        print(self.norm2(self.x, self.y))

    def get_coord(self):
        return self.x, self.y

    @staticmethod
    def norm2(x, y):
        return x ** 2 + y ** 2


v = Vector(1, 2)
v1 = Vector(1, 200)
validate = Vector.validate(5)
print(validate)
res = Vector.get_coord(v)
res1 = Vector.get_coord(v1)
print(res)
print(res1)
print(Vector.norm2(5, 6))
