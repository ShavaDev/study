"""
РЕЗЮМЕ

Любое обращение через точку (self.something = ... или return self.something) внутри магических методов,
которые этот доступ контролируют, ведет к самовызову.
Контроль доступа через магические методы — это возможность вклиниться
в процесс чтения/записи атрибутов и добавить туда свою логику (проверку, трансформацию, запрет)

Правило большого пальца: Если ты переопределяешь методы управления доступом
(__getattribute__, __setattr__, __delattr__), всегда используй реализацию object, чтобы выполнить фактическую работу.
"""

class Point:
    MAX_COORDINATES = 100
    MIN_COORDINATES = 0

    def __init__(self, x, y):
        self.__x = x
        self.y = y

    def set_coordinates(self, x, y):
        if self.MIN_COORDINATES <= x <= self.MAX_COORDINATES:
            self.__x = x
            self.y = y

    @classmethod
    def set_bounds(cls, left, right):
        """
        Функция для обращения и изменения атрибута самого класса
        при этом в локальной области видимости экземпляра класса не создается данная переменная,
        а изменяется в самом классе
        :param left:
        :param right:
        :return:
        """
        cls.MIN_COORDINATES = left
        cls.MAX_COORDINATES = right

    def __getattribute__(self, name):
        """
        автоматически вызывается при получении свойства класса с именем name
        здесь добавлен новый магический метод __getattribute__. Он автоматически вызывается,
        когда идет считывание атрибута через экземпляр класса. Например, при обращении к свойству MIN_COORD
        Или к приватному свойству через специальное имя pt1._Point__x
        Но раз это так, то давайте явно запретим считывать такой атрибут из экземпляра класса.
        Для этого пропишем в методе __getattribute__ проверку
        То есть, мы смотрим, если идет обращение к приватному атрибуту по внешнему имени _Point__x,
        то генерируем исключение ValueError. И, действительно, после запуска программы видим отображение
        этой ошибки в консоли. Вот так, через магический метод __getattribute__ можно реализовывать определенную
        логику при обращении к атрибутам через экземпляр класса

        с __getattribute__ такая же беда (рекурсия)
        Python скажет: «Ага, ты хочешь получить x? Тогда я вызываю __getattribute__!». И мы снова в петле
        :param name:
        :return:
        """
        print("__getattribute__")
        if name == "_Point__x":
            raise ValueError("Доступ запрещен")
        return object.__getattribute__(self, name)

    def __setattr__(self, name, value):
        """
        автоматически вызывается при изменении свойства name класса
        метод __setattr__ автоматически вызывается в момент присваивания атрибуту нового значения
        После запуска видим несколько сообщений «__setattr__». Это связано с тем, что в момент создания
        экземпляров класса в инициализаторе __init__ создавались локальные свойства __x и __y.
        В этот момент вызывался данный метод. Также в переопределенном методе __setattr__ мы должны вызывать
        соответствующий метод из базового класса object, иначе, локальные свойства в экземплярах создаваться не будут
        теперь для примера через этот магический метод запретим создание локального свойства с именем z
        Обратите внимание, что внутри метода __setattr__ нельзя менять свойства напрямую self.__x = value
        В этом случае метод __setattr__ начнет выполняться по рекурсии, пока не возникнет ошибка
        достижения максимальной глубины рекурсии. Если нужно сделать что-то подобное, то используйте коллекцию __dict__
        или, если требуется стандартное поведение метода, то вызывайте его из класса object

        Для Python эта строчка кода буквально означает: «Вызови метод __setattr__ для объекта self,
        передай туда имя "x" и значение value».
        Получается бесконечный цикл:
        Ты пытаешься изменить self.x.
        Python видит это и вызывает __setattr__.
        Внутри __setattr__ ты снова пишешь self.x = value.
        Python видит это и снова вызывает __setattr__.
        И так до тех пор, пока не закончится стек вызовов и Python не выдаст:
        RecursionError: maximum recursion depth exceeded
        :param name:
        :param value:
        :return:
        """
        print("__setattr__")
        if name == "z":
            raise AttributeError("не допустимое имя атрибута!")
        else:
            # self.__x = value
            object.__setattr__(self, name, value)
            # self.__dict__[name] = value

    def __getattr__(self, name):
        """
        автоматически вызывается при получении несуществующего свойства name класса
        автоматически вызывается, если идет обращение к несуществующему атрибуту
        Если ниже обратиться к несуществующему свойству, то увидим сообщение «__getattr__x» и
        значение None, которое вернул данный метод. Если же прописать существующий атрибут
        то этот магический метод уже не вызывается. Зачем он может понадобиться?
        Например, нам необходимо определить класс, в котором при обращении к несуществующим
        атрибутам возвращается значение False, а не генерируется исключение. Для этого записывается метод __getattr__
        в виде return False

        Исключение: __getattr__
        А вот здесь рекурсии не будет! Почему?
        Потому что __getattr__ вызывается только тогда, когда атрибут не найден обычными способами.
        Если ты внутри __getattr__ обратишься к self.existing_attribute, Python найдет его
        через стандартные механизмы и не будет вызывать __getattr__ снова
        :param name:
        :return:
        """
        print("__getattr__" + name)
        # return object.__getattribute__(self, name)
        return False

    def __delattr__(self, name):
        """
        автоматически вызывается при удалении свойства name (не важно: существует оно или нет)
        магический метод __delattr__ вызывается в момент удаления какого-либо атрибута из экземпляра класса
        затем выполним команду его удаления: del pt1.y
        и видим, что действительно был вызван метод __delattr__, правда, сам атрибут удален не был
        Это из-за того, что внутри этого метода нужно вызвать соответствующий метод класса object, который и
        выполняет непосредственное удаление
        :param name:
        :return:
        """
        print("__delattr__ " + name)
        object.__delattr__(self, name)


pt1 = Point(1, 2) # __setattr__
pt2 = Point(10, 20) # __setattr__
# pt1.set_bounds(-100, 200)
# print(Point.__dict__)
# print(pt1.y) # __getattribute__
# pt1.g = "global" # __setattr__
# print(pt1.c) # __getattr__ + __getattribute__
# del pt2._Point__x # __delattr__
